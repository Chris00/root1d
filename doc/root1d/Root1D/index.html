<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Root1D (root1d.Root1D)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="generator" content="doc-ock-html v1.0.0-1-g1fc9bf0"/></head><body><nav id="top"><a href="../index.html">Up</a> &mdash; <span class="package">package <a href="../index.html">root1d</a></span></nav><header><h1><span class="keyword">Module</span> <span class="module-path">Root1D</span></h1></header><p>1D Root finding algorithms.</p><ul class="at-tag"><li><span class="at-tag version">Version</span>: 0.5.1</li></ul><div class="spec val" id="val-brent"><a href="#val-brent" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>brent : ?&#8288;tol:float <span class="keyword">&#8209;&gt;</span> (float <span class="keyword">&#8209;&gt;</span> float) <span class="keyword">&#8209;&gt;</span> float <span class="keyword">&#8209;&gt;</span> float <span class="keyword">&#8209;&gt;</span> float</code></div><div class="doc"><p><code class="code">brent f a b</code> returns an approximation <code class="code">x</code> of a root of <code class="code">f</code> in
the interval <code class="code">[a,b]</code> with absolute accuracy <code class="code">6. *. epsilon_float
    *. abs_float(x) +. tol</code>.</p><ul class="at-tag"><li><span class="at-tag raise">Raises</span> <span class="module-path">Invalid_argument</span>: if <code class="code">f(a) *. f(b) &gt; 0.</code>.</li><li><p><span class="at-tag parameter">Parameter</span> <span class="module-path">tol</span>: desired length of the interval of uncertainty of the final
result (must be <code class="code">&gt;= 0</code>). Default: <code class="code">sqrt epsilon_float</code>.</p><p>Ref.: Brent, R. (1973) Algorithms for Minimization without
Derivatives. Englewood Cliffs, NJ: Prentice-Hall.</p></li></ul></div></div><div class="spec val" id="val-bisection"><a href="#val-bisection" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>bisection : ?&#8288;eps:float <span class="keyword">&#8209;&gt;</span> (float <span class="keyword">&#8209;&gt;</span> float) <span class="keyword">&#8209;&gt;</span> float <span class="keyword">&#8209;&gt;</span> float <span class="keyword">&#8209;&gt;</span> float</code></div><div class="doc"><p><code class="code">bisection f a b</code> find an approximation of a root in the
interval <code class="code">[a,b]</code> using the bisection algorithm.</p><ul class="at-tag"><li><span class="at-tag raise">Raises</span> <span class="module-path">Invalid_argument</span>: if <code class="code">f(a) *. f(b) &gt; 0.</code> or <code class="code">eps &lt;= 0.</code></li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">eps</span>: is the desired relative error on the solution. More
precisely, it terminates when the interval [a,b] verifies
|a-b| ≤ eps max(|a|, |b|). Default: <code class="code">sqrt epsilon_float</code>.</li></ul></div></div><div class="spec val" id="val-illinois"><a href="#val-illinois" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>illinois : ?&#8288;eps:float <span class="keyword">&#8209;&gt;</span> (float <span class="keyword">&#8209;&gt;</span> float) <span class="keyword">&#8209;&gt;</span> float <span class="keyword">&#8209;&gt;</span> float <span class="keyword">&#8209;&gt;</span> float</code></div><div class="doc"><p><code class="code">illinois f a b</code> find an approximation of a root in the interval
<code class="code">[a,b]</code> using the Illinois algorithm (which is the Regula Falsi
method with a small twist). Order of convergence: ³√3 ≈ 1.442.</p><ul class="at-tag"><li><span class="at-tag raise">Raises</span> <span class="module-path">Invalid_argument</span>: if <code class="code">f(a) *. f(b) &gt; 0.</code> or <code class="code">eps &lt;= 0.</code></li><li><p><span class="at-tag parameter">Parameter</span> <span class="module-path">eps</span>: is the desired relative error on the solution. More
precisely, it terminates when the interval [a,b] verifies
|a-b| ≤ eps max(|a|, |b|). Default: <code class="code">sqrt epsilon_float</code>.</p><p>Ref.: <a href="http://link.springer.com/article/10.1007/BF01934364">M. Dowell, P. Jarrat, A modified Regula Falsi method for
computing the root of anequation, BIT 11 (1971), 168–174</a>.</p></li></ul></div></div><div class="spec val" id="val-newton"><a href="#val-newton" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>newton : ?&#8288;good_enough:(float <span class="keyword">&#8209;&gt;</span> float <span class="keyword">&#8209;&gt;</span> float <span class="keyword">&#8209;&gt;</span> bool) <span class="keyword">&#8209;&gt;</span> (float <span class="keyword">&#8209;&gt;</span> float<span class="keyword"> * </span>float) <span class="keyword">&#8209;&gt;</span> float <span class="keyword">&#8209;&gt;</span> float</code></div><div class="doc"><p><code class="code">newton f_f' x0</code> returns an approximate root of <code class="code">f</code> close to the
initial guess <code class="code">x0</code> using Newton's method. <code class="code">f_f'</code> is a function
such that <code class="code">f_f' x</code> returns the couple <code class="code">(f x, f' x)</code> where <code class="code">f' x</code>
is the derivative of <code class="code">f</code> at <code class="code">x</code>.</p><ul class="at-tag"><li><span class="at-tag raise">Raises</span> <span class="module-path">Failure</span>: if the derivative vanishes during the
computations.</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">good_enough</span>: takes as arguments the current approximation
<code class="code">x</code>, the previous approximation <code class="code">xprev</code>, and <code class="code">f(x)</code> and returns
whether <code class="code">x</code> is a good enough approximation. Default:
<code class="code">abs_float(f x) &lt; sqrt epsilon_float</code>.</li></ul></div></div><div class="spec val" id="val-brent2"><a href="#val-brent2" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>brent2 : ?&#8288;tol:float <span class="keyword">&#8209;&gt;</span> (float <span class="keyword">&#8209;&gt;</span> float<span class="keyword"> * </span>int) <span class="keyword">&#8209;&gt;</span> float <span class="keyword">&#8209;&gt;</span> float <span class="keyword">&#8209;&gt;</span> float</code></div><div class="doc"><p><code class="code">brent2 f a b</code> finds a zero of the function <code class="code">f</code> in the same way
<code class="code">brent f a b</code> does except that <code class="code">f x</code> returns the couple <code class="code">(y, z)</code>
for the number <code class="code">y * 2**z</code>. Thus underflow and overflow can be
avoided for a function with large range.</p><p>Ref.: Brent, R. (1973) Algorithms for Minimization without
Derivatives. Englewood Cliffs, NJ: Prentice-Hall.</p></div></div></body></html>